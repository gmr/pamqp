"""
AMQP Classes & Methods
======================

"""
# Auto-generated, do not edit this file.
import datetime
import typing
import warnings

from pamqp import base, common, constants


class Connection:
    """Work with socket connections

    The connection class provides methods for a client to establish a network
    connection to a server, and for both peers to operate the connection
    thereafter.

    """
    __slots__: typing.List[str] = []

    frame_id = 10  # AMQP Frame ID
    index = 0x000A0000  # pamqp Mapping Index

    class Start(base.Frame):
        """Start connection negotiation

        This method starts the connection negotiation process by telling the
        client the protocol version that the server proposes, along with a list
        of security mechanisms which the client can use for authentication.

        """
        __annotations__: typing.Dict[str, object] = {
            'version_major': int,
            'version_minor': int,
            'server_properties': typing.Optional[
                typing.Dict[str, common.FieldValue]],
            'mechanisms': str,
            'locales': str
        }
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'version_major', 'version_minor', 'server_properties',
            'mechanisms', 'locales'
        ]

        frame_id = 10  # AMQP Frame ID
        index = 0x000A000A  # pamqp Mapping Index
        name = 'Connection.Start'
        synchronous = True  # Indicates if this is a synchronous AMQP method
        # Valid responses to this method
        valid_responses = ['Connection.StartOk']

        # Class Attribute Types for unmarshaling
        _version_major = 'octet'
        _version_minor = 'octet'
        _server_properties = 'table'
        _mechanisms = 'longstr'
        _locales = 'longstr'

        def __init__(self,
                     version_major: int = 0,
                     version_minor: int = 9,
                     server_properties: typing.Optional[
                         typing.Dict[str, common.FieldValue]] = None,
                     mechanisms: str = 'PLAIN',
                     locales: str = 'en_US') -> None:
            """Initialize the :py:class:`Connection.Start` class

            :param version_major: Protocol major version
            :param version_minor: Protocol minor version
            :param server_properties: This table provides a set of peer
                properties, used for identification, debugging, and general
                information.
            :param mechanisms: Available security mechanisms
            :param locales: Available message locales

            """
            self.version_major = version_major
            self.version_minor = version_minor
            self.server_properties = server_properties or {}
            self.mechanisms = mechanisms
            self.locales = locales

    class StartOk(base.Frame):
        """Select security mechanism and locale

        This method selects a SASL security mechanism.

        """
        __annotations__: typing.Dict[str, object] = {
            'client_properties': typing.Optional[
                typing.Dict[str, common.FieldValue]],
            'mechanism': str,
            'response': str,
            'locale': str
        }
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'client_properties', 'mechanism', 'response', 'locale'
        ]

        frame_id = 11  # AMQP Frame ID
        index = 0x000A000B  # pamqp Mapping Index
        name = 'Connection.StartOk'
        synchronous = False  # Indicates if this is a synchronous AMQP method

        # Class Attribute Types for unmarshaling
        _client_properties = 'table'
        _mechanism = 'shortstr'
        _response = 'longstr'
        _locale = 'shortstr'

        def __init__(self,
                     client_properties: typing.Optional[
                         typing.Dict[str, common.FieldValue]] = None,
                     mechanism: str = 'PLAIN',
                     response: str = '',
                     locale: str = 'en_US') -> None:
            """Initialize the :py:class:`Connection.StartOk` class

            :param client_properties: This table provides a set of peer
                properties, used for identification, debugging, and general
                information.
            :param mechanism: Selected security mechanism
            :param response: Security response data
            :param locale: Selected message locale

            """
            self.client_properties = client_properties or {}
            self.mechanism = mechanism
            self.response = response
            self.locale = locale

    class Secure(base.Frame):
        """Security mechanism challenge

        The SASL protocol works by exchanging challenges and responses until
        both peers have received sufficient information to authenticate each
        other. This method challenges the client to provide more information.

        """
        __annotations__: typing.Dict[str, object] = {'challenge': str}
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'challenge'
        ]

        frame_id = 20  # AMQP Frame ID
        index = 0x000A0014  # pamqp Mapping Index
        name = 'Connection.Secure'
        synchronous = True  # Indicates if this is a synchronous AMQP method
        # Valid responses to this method
        valid_responses = ['Connection.SecureOk']

        # Class Attribute Types for unmarshaling
        _challenge = 'longstr'

        def __init__(self, challenge: str = '') -> None:
            """Initialize the :py:class:`Connection.Secure` class

            :param challenge: Security challenge data

            """
            self.challenge = challenge

    class SecureOk(base.Frame):
        """Security mechanism response

        This method attempts to authenticate, passing a block of SASL data for
        the security mechanism at the server side.

        """
        __annotations__: typing.Dict[str, object] = {'response': str}
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'response'
        ]

        frame_id = 21  # AMQP Frame ID
        index = 0x000A0015  # pamqp Mapping Index
        name = 'Connection.SecureOk'
        synchronous = False  # Indicates if this is a synchronous AMQP method

        # Class Attribute Types for unmarshaling
        _response = 'longstr'

        def __init__(self, response: str = '') -> None:
            """Initialize the :py:class:`Connection.SecureOk` class

            :param response: Security response data

            """
            self.response = response

    class Tune(base.Frame):
        """Propose connection tuning parameters

        This method proposes a set of connection configuration values to the
        client. The client can accept and/or adjust these.

        """
        __annotations__: typing.Dict[str, object] = {
            'channel_max': int,
            'frame_max': int,
            'heartbeat': int
        }
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'channel_max', 'frame_max', 'heartbeat'
        ]

        frame_id = 30  # AMQP Frame ID
        index = 0x000A001E  # pamqp Mapping Index
        name = 'Connection.Tune'
        synchronous = True  # Indicates if this is a synchronous AMQP method
        # Valid responses to this method
        valid_responses = ['Connection.TuneOk']

        # Class Attribute Types for unmarshaling
        _channel_max = 'short'
        _frame_max = 'long'
        _heartbeat = 'short'

        def __init__(self,
                     channel_max: int = 0,
                     frame_max: int = 0,
                     heartbeat: int = 0) -> None:
            """Initialize the :py:class:`Connection.Tune` class

            :param channel_max: Proposed maximum channels
            :param frame_max: Proposed maximum frame size
            :param heartbeat: Desired heartbeat delay

            """
            self.channel_max = channel_max
            self.frame_max = frame_max
            self.heartbeat = heartbeat

    class TuneOk(base.Frame):
        """Negotiate connection tuning parameters

        This method sends the client's connection tuning parameters to the
        server. Certain fields are negotiated, others provide capability
        information.

        """
        __annotations__: typing.Dict[str, object] = {
            'channel_max': int,
            'frame_max': int,
            'heartbeat': int
        }
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'channel_max', 'frame_max', 'heartbeat'
        ]

        frame_id = 31  # AMQP Frame ID
        index = 0x000A001F  # pamqp Mapping Index
        name = 'Connection.TuneOk'
        synchronous = False  # Indicates if this is a synchronous AMQP method

        # Class Attribute Types for unmarshaling
        _channel_max = 'short'
        _frame_max = 'long'
        _heartbeat = 'short'

        def __init__(self,
                     channel_max: int = 0,
                     frame_max: int = 0,
                     heartbeat: int = 0) -> None:
            """Initialize the :py:class:`Connection.TuneOk` class

            :param channel_max: Negotiated maximum channels
            :param frame_max: Negotiated maximum frame size
            :param heartbeat: Desired heartbeat delay

            """
            self.channel_max = channel_max
            self.frame_max = frame_max
            self.heartbeat = heartbeat

    class Open(base.Frame):
        """Open connection to virtual host

        This method opens a connection to a virtual host, which is a collection
        of resources, and acts to separate multiple application domains within
        a server. The server may apply arbitrary limits per virtual host, such
        as the number of each type of entity that may be used, per connection
        and/or in total.

        """
        __annotations__: typing.Dict[str, object] = {
            'virtual_host': str,
            'capabilities': str,
            'insist': bool
        }
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'virtual_host', 'capabilities', 'insist'
        ]

        frame_id = 40  # AMQP Frame ID
        index = 0x000A0028  # pamqp Mapping Index
        name = 'Connection.Open'
        synchronous = True  # Indicates if this is a synchronous AMQP method
        # Valid responses to this method
        valid_responses = ['Connection.OpenOk']

        # Class Attribute Types for unmarshaling
        _virtual_host = 'shortstr'
        _capabilities = 'shortstr'
        _insist = 'bit'

        def __init__(self,
                     virtual_host: str = '/',
                     capabilities: str = '',
                     insist: bool = False) -> None:
            """Initialize the :py:class:`Connection.Open` class

            :param virtual_host: Unconstrained.
            :param capabilities: Deprecated, must be empty
            :param insist: Deprecated, must be ``False``
            :raises: ValueError

            """
            self.virtual_host = virtual_host
            if len(self.virtual_host) > 127:
                raise ValueError('Max length exceeded for virtual_host')
            self.capabilities = capabilities
            if self.capabilities != '':
                raise ValueError('capabilities must be empty')
            self.insist = insist
            if self.insist is not False:
                raise ValueError('insist must be False')

    class OpenOk(base.Frame):
        """Signal that connection is ready

        This method signals to the client that the connection is ready for use.

        """
        __annotations__: typing.Dict[str, object] = {'known_hosts': str}
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'known_hosts'
        ]

        frame_id = 41  # AMQP Frame ID
        index = 0x000A0029  # pamqp Mapping Index
        name = 'Connection.OpenOk'
        synchronous = False  # Indicates if this is a synchronous AMQP method

        # Class Attribute Types for unmarshaling
        _known_hosts = 'shortstr'

        def __init__(self, known_hosts: str = '') -> None:
            """Initialize the :py:class:`Connection.OpenOk` class

            :param known_hosts: Deprecated, must be empty

            """
            self.known_hosts = known_hosts
            if self.known_hosts != '':
                raise ValueError('known_hosts must be empty')

    class Close(base.Frame):
        """Request a connection close

        This method indicates that the sender wants to close the connection.
        This may be due to internal conditions (e.g. a forced shut-down) or due
        to an error handling a specific method, i.e. an exception. When a close
        is due to an exception, the sender provides the class and method id of
        the method which caused the exception.

        """
        __annotations__: typing.Dict[str, object] = {
            'reply_code': int,
            'reply_text': str,
            'class_id': int,
            'method_id': int
        }
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'reply_code', 'reply_text', 'class_id', 'method_id'
        ]

        frame_id = 50  # AMQP Frame ID
        index = 0x000A0032  # pamqp Mapping Index
        name = 'Connection.Close'
        synchronous = True  # Indicates if this is a synchronous AMQP method
        # Valid responses to this method
        valid_responses = ['Connection.CloseOk']

        # Class Attribute Types for unmarshaling
        _reply_code = 'short'
        _reply_text = 'shortstr'
        _class_id = 'short'
        _method_id = 'short'

        def __init__(self,
                     reply_code: int = 0,
                     reply_text: str = '',
                     class_id: int = 0,
                     method_id: int = 0) -> None:
            """Initialize the :py:class:`Connection.Close` class

            :param reply_code: reply code from server
            :param reply_text: localised reply text
            :param class_id: Failing method class
            :param method_id: Failing method ID

            """
            self.reply_code = reply_code
            self.reply_text = reply_text
            self.class_id = class_id
            self.method_id = method_id

    class CloseOk(base.Frame):
        """Confirm a connection close

        This method confirms a Connection.Close method and tells the recipient
        that it is safe to release resources for the connection and close the
        socket.

        """
        __annotations__: typing.Dict[str, object] = {}
        __slots__: typing.List[str] = []  # AMQ Method Attributes

        frame_id = 51  # AMQP Frame ID
        index = 0x000A0033  # pamqp Mapping Index
        name = 'Connection.CloseOk'
        synchronous = False  # Indicates if this is a synchronous AMQP method

    class Blocked(base.Frame):
        """Indicate that connection is blocked

        This method indicates that a connection has been blocked and does not
        accept new publishes.

        """
        __annotations__: typing.Dict[str, object] = {'reason': str}
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'reason'
        ]

        frame_id = 60  # AMQP Frame ID
        index = 0x000A003C  # pamqp Mapping Index
        name = 'Connection.Blocked'
        synchronous = False  # Indicates if this is a synchronous AMQP method

        # Class Attribute Types for unmarshaling
        _reason = 'shortstr'

        def __init__(self, reason: str = '') -> None:
            """Initialize the :py:class:`Connection.Blocked` class

            :param reason: Block reason

            """
            self.reason = reason

    class Unblocked(base.Frame):
        """Indicate that connection is unblocked

        This method indicates that a connection has been unblocked and now
        accepts publishes.

        """
        __annotations__: typing.Dict[str, object] = {}
        __slots__: typing.List[str] = []  # AMQ Method Attributes

        frame_id = 61  # AMQP Frame ID
        index = 0x000A003D  # pamqp Mapping Index
        name = 'Connection.Unblocked'
        synchronous = False  # Indicates if this is a synchronous AMQP method

    class UpdateSecret(base.Frame):
        """Update secret

        This method updates the secret used to authenticate this connection. It
        is used when secrets have an expiration date and need to be renewed,
        like OAuth 2 tokens.

        """
        __annotations__: typing.Dict[str, object] = {
            'new_secret': str,
            'reason': str
        }
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'new_secret', 'reason'
        ]

        frame_id = 70  # AMQP Frame ID
        index = 0x000A0046  # pamqp Mapping Index
        name = 'Connection.UpdateSecret'
        synchronous = True  # Indicates if this is a synchronous AMQP method
        # Valid responses to this method
        valid_responses = ['Connection.UpdateSecretOk']

        # Class Attribute Types for unmarshaling
        _new_secret = 'longstr'
        _reason = 'shortstr'

        def __init__(self, new_secret: str = '', reason: str = '') -> None:
            """Initialize the :py:class:`Connection.UpdateSecret` class

            :param new_secret: New secret
            :param reason: Reason

            """
            self.new_secret = new_secret
            self.reason = reason

    class UpdateSecretOk(base.Frame):
        """Update secret response

        This method confirms the updated secret is valid.

        """
        __annotations__: typing.Dict[str, object] = {}
        __slots__: typing.List[str] = []  # AMQ Method Attributes

        frame_id = 71  # AMQP Frame ID
        index = 0x000A0047  # pamqp Mapping Index
        name = 'Connection.UpdateSecretOk'
        synchronous = False  # Indicates if this is a synchronous AMQP method


class Channel:
    """Work with channels

    The channel class provides methods for a client to establish a channel to a
    server and for both peers to operate the channel thereafter.

    """
    __slots__: typing.List[str] = []

    frame_id = 20  # AMQP Frame ID
    index = 0x00140000  # pamqp Mapping Index

    class Open(base.Frame):
        """Open a channel for use

        This method opens a channel to the server.

        """
        __annotations__: typing.Dict[str, object] = {'out_of_band': str}
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'out_of_band'
        ]

        frame_id = 10  # AMQP Frame ID
        index = 0x0014000A  # pamqp Mapping Index
        name = 'Channel.Open'
        synchronous = True  # Indicates if this is a synchronous AMQP method
        valid_responses = ['Channel.OpenOk']  # Valid responses to this method

        # Class Attribute Types for unmarshaling
        _out_of_band = 'shortstr'

        def __init__(self, out_of_band: str = '') -> None:
            """Initialize the :py:class:`Channel.Open` class

            :param out_of_band: Protocol level field, do not use, must be
                ``0``.

            """
            self.out_of_band = out_of_band
            if self.out_of_band != '':
                raise ValueError('out_of_band must be empty')

    class OpenOk(base.Frame):
        """Signal that the channel is ready

        This method signals to the client that the channel is ready for use.

        """
        __annotations__: typing.Dict[str, object] = {'channel_id': str}
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'channel_id'
        ]

        frame_id = 11  # AMQP Frame ID
        index = 0x0014000B  # pamqp Mapping Index
        name = 'Channel.OpenOk'
        synchronous = False  # Indicates if this is a synchronous AMQP method

        # Class Attribute Types for unmarshaling
        _channel_id = 'longstr'

        def __init__(self, channel_id: str = '') -> None:
            """Initialize the :py:class:`Channel.OpenOk` class

            :param channel_id: Deprecated, must be empty

            """
            self.channel_id = channel_id
            if self.channel_id != '':
                raise ValueError('channel_id must be empty')

    class Flow(base.Frame):
        """Enable/disable flow from peer

        This method asks the peer to pause or restart the flow of content data
        sent by a consumer. This is a simple flow-control mechanism that a peer
        can use to avoid overflowing its queues or otherwise finding itself
        receiving more messages than it can process. Note that this method is
        not intended for window control. It does not affect contents returned
        by Basic.Get-Ok methods.

        """
        __annotations__: typing.Dict[str, object] = {'active': bool}
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'active'
        ]

        frame_id = 20  # AMQP Frame ID
        index = 0x00140014  # pamqp Mapping Index
        name = 'Channel.Flow'
        synchronous = True  # Indicates if this is a synchronous AMQP method
        valid_responses = ['Channel.FlowOk']  # Valid responses to this method

        # Class Attribute Types for unmarshaling
        _active = 'bit'

        def __init__(self, active: bool = False) -> None:
            """Initialize the :py:class:`Channel.Flow` class

            :param active: Start/stop content frames

            """
            self.active = active

    class FlowOk(base.Frame):
        """Confirm a flow method

        Confirms to the peer that a flow command was received and processed.

        """
        __annotations__: typing.Dict[str, object] = {'active': bool}
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'active'
        ]

        frame_id = 21  # AMQP Frame ID
        index = 0x00140015  # pamqp Mapping Index
        name = 'Channel.FlowOk'
        synchronous = False  # Indicates if this is a synchronous AMQP method

        # Class Attribute Types for unmarshaling
        _active = 'bit'

        def __init__(self, active: bool = False) -> None:
            """Initialize the :py:class:`Channel.FlowOk` class

            :param active: Current flow setting

            """
            self.active = active

    class Close(base.Frame):
        """Request a channel close

        This method indicates that the sender wants to close the channel. This
        may be due to internal conditions (e.g. a forced shut-down) or due to
        an error handling a specific method, i.e. an exception. When a close is
        due to an exception, the sender provides the class and method id of the
        method which caused the exception.

        """
        __annotations__: typing.Dict[str, object] = {
            'reply_code': int,
            'reply_text': str,
            'class_id': int,
            'method_id': int
        }
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'reply_code', 'reply_text', 'class_id', 'method_id'
        ]

        frame_id = 40  # AMQP Frame ID
        index = 0x00140028  # pamqp Mapping Index
        name = 'Channel.Close'
        synchronous = True  # Indicates if this is a synchronous AMQP method
        # Valid responses to this method
        valid_responses = ['Channel.CloseOk']

        # Class Attribute Types for unmarshaling
        _reply_code = 'short'
        _reply_text = 'shortstr'
        _class_id = 'short'
        _method_id = 'short'

        def __init__(self,
                     reply_code: int = 0,
                     reply_text: str = '',
                     class_id: int = 0,
                     method_id: int = 0) -> None:
            """Initialize the :py:class:`Channel.Close` class

            :param reply_code: reply code from server
            :param reply_text: localised reply text
            :param class_id: Failing method class
            :param method_id: Failing method ID

            """
            self.reply_code = reply_code
            self.reply_text = reply_text
            self.class_id = class_id
            self.method_id = method_id

    class CloseOk(base.Frame):
        """Confirm a channel close

        This method confirms a Channel.Close method and tells the recipient
        that it is safe to release resources for the channel.

        """
        __annotations__: typing.Dict[str, object] = {}
        __slots__: typing.List[str] = []  # AMQ Method Attributes

        frame_id = 41  # AMQP Frame ID
        index = 0x00140029  # pamqp Mapping Index
        name = 'Channel.CloseOk'
        synchronous = False  # Indicates if this is a synchronous AMQP method


class Exchange:
    """Work with exchanges

    Exchanges match and distribute messages across queues. Exchanges can be
    configured in the server or declared at runtime.

    """
    __slots__: typing.List[str] = []

    frame_id = 40  # AMQP Frame ID
    index = 0x00280000  # pamqp Mapping Index

    class Declare(base.Frame):
        """Verify exchange exists, create if needed

        This method creates an exchange if it does not already exist, and if
        the exchange exists, verifies that it is of the correct and expected
        class.

        """
        __annotations__: typing.Dict[str, object] = {
            'ticket': int,
            'exchange': str,
            'exchange_type': str,
            'passive': bool,
            'durable': bool,
            'auto_delete': bool,
            'internal': bool,
            'nowait': bool,
            'arguments': typing.Optional[typing.Dict[str, common.FieldValue]]
        }
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'ticket', 'exchange', 'exchange_type', 'passive', 'durable',
            'auto_delete', 'internal', 'nowait', 'arguments'
        ]

        frame_id = 10  # AMQP Frame ID
        index = 0x0028000A  # pamqp Mapping Index
        name = 'Exchange.Declare'
        synchronous = True  # Indicates if this is a synchronous AMQP method
        # Valid responses to this method
        valid_responses = ['Exchange.DeclareOk']

        # Class Attribute Types for unmarshaling
        _ticket = 'short'
        _exchange = 'shortstr'
        _exchange_type = 'shortstr'
        _passive = 'bit'
        _durable = 'bit'
        _auto_delete = 'bit'
        _internal = 'bit'
        _nowait = 'bit'
        _arguments = 'table'

        def __init__(self,
                     ticket: int = 0,
                     exchange: str = '',
                     exchange_type: str = 'direct',
                     passive: bool = False,
                     durable: bool = False,
                     auto_delete: bool = False,
                     internal: bool = False,
                     nowait: bool = False,
                     arguments: typing.Optional[
                         typing.Dict[str, common.FieldValue]] = None) -> None:
            """Initialize the :py:class:`Exchange.Declare` class

            .. note:: The AMQP type argument is referred to as "exchange_type"
                      to not conflict with the Python type keyword.

            :param ticket: Deprecated, must be ``0``
            :param exchange: exchange name
            :param exchange_type: Exchange type
            :param passive: Do not create exchange
            :param durable: Request a durable exchange
            :param auto_delete: Auto-delete when unused
            :param internal: Create internal exchange
            :param nowait: Do not send a reply method
            :param arguments: Arguments for declaration
            :raises: ValueError

            """
            self.ticket = ticket
            if self.ticket != 0:
                raise ValueError('ticket must be 0')
            self.exchange = exchange
            if len(self.exchange) > 127:
                raise ValueError('Max length exceeded for exchange')
            if not constants.DOMAIN_REGEX['exchange-name'].fullmatch(
                    self.exchange):
                raise ValueError('Invalid value for exchange')
            self.exchange_type = exchange_type
            self.passive = passive
            self.durable = durable
            self.auto_delete = auto_delete
            self.internal = internal
            if self.internal is not False:
                raise ValueError('internal must be False')
            self.nowait = nowait
            self.arguments = arguments or {}

    class DeclareOk(base.Frame):
        """Confirm exchange declaration

        This method confirms a Declare method and confirms the name of the
        exchange, essential for automatically-named exchanges.

        """
        __annotations__: typing.Dict[str, object] = {}
        __slots__: typing.List[str] = []  # AMQ Method Attributes

        frame_id = 11  # AMQP Frame ID
        index = 0x0028000B  # pamqp Mapping Index
        name = 'Exchange.DeclareOk'
        synchronous = False  # Indicates if this is a synchronous AMQP method

    class Delete(base.Frame):
        """Delete an exchange

        This method deletes an exchange. When an exchange is deleted all queue
        bindings on the exchange are cancelled.

        """
        __annotations__: typing.Dict[str, object] = {
            'ticket': int,
            'exchange': str,
            'if_unused': bool,
            'nowait': bool
        }
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'ticket', 'exchange', 'if_unused', 'nowait'
        ]

        frame_id = 20  # AMQP Frame ID
        index = 0x00280014  # pamqp Mapping Index
        name = 'Exchange.Delete'
        synchronous = True  # Indicates if this is a synchronous AMQP method
        # Valid responses to this method
        valid_responses = ['Exchange.DeleteOk']

        # Class Attribute Types for unmarshaling
        _ticket = 'short'
        _exchange = 'shortstr'
        _if_unused = 'bit'
        _nowait = 'bit'

        def __init__(self,
                     ticket: int = 0,
                     exchange: str = '',
                     if_unused: bool = False,
                     nowait: bool = False) -> None:
            """Initialize the :py:class:`Exchange.Delete` class

            :param ticket: Deprecated, must be ``0``
            :param exchange: exchange name
            :param if_unused: Delete only if unused
            :param nowait: Do not send a reply method
            :raises: ValueError

            """
            self.ticket = ticket
            if self.ticket != 0:
                raise ValueError('ticket must be 0')
            self.exchange = exchange
            if len(self.exchange) > 127:
                raise ValueError('Max length exceeded for exchange')
            if not constants.DOMAIN_REGEX['exchange-name'].fullmatch(
                    self.exchange):
                raise ValueError('Invalid value for exchange')
            self.if_unused = if_unused
            self.nowait = nowait

    class DeleteOk(base.Frame):
        """Confirm deletion of an exchange

        This method confirms the deletion of an exchange.

        """
        __annotations__: typing.Dict[str, object] = {}
        __slots__: typing.List[str] = []  # AMQ Method Attributes

        frame_id = 21  # AMQP Frame ID
        index = 0x00280015  # pamqp Mapping Index
        name = 'Exchange.DeleteOk'
        synchronous = False  # Indicates if this is a synchronous AMQP method

    class Bind(base.Frame):
        """Bind exchange to an exchange

        This method binds an exchange to an exchange.

        """
        __annotations__: typing.Dict[str, object] = {
            'ticket': int,
            'destination': str,
            'source': str,
            'routing_key': str,
            'nowait': bool,
            'arguments': typing.Optional[typing.Dict[str, common.FieldValue]]
        }
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'ticket', 'destination', 'source', 'routing_key', 'nowait',
            'arguments'
        ]

        frame_id = 30  # AMQP Frame ID
        index = 0x0028001E  # pamqp Mapping Index
        name = 'Exchange.Bind'
        synchronous = True  # Indicates if this is a synchronous AMQP method
        # Valid responses to this method
        valid_responses = ['Exchange.BindOk']

        # Class Attribute Types for unmarshaling
        _ticket = 'short'
        _destination = 'shortstr'
        _source = 'shortstr'
        _routing_key = 'shortstr'
        _nowait = 'bit'
        _arguments = 'table'

        def __init__(self,
                     ticket: int = 0,
                     destination: str = '',
                     source: str = '',
                     routing_key: str = '',
                     nowait: bool = False,
                     arguments: typing.Optional[
                         typing.Dict[str, common.FieldValue]] = None) -> None:
            """Initialize the :py:class:`Exchange.Bind` class

            :param ticket: Deprecated, must be ``0``
            :param destination: exchange name
            :param source: exchange name
            :param routing_key: Message routing key
            :param nowait: Do not send a reply method
            :param arguments: Arguments for binding
            :raises: ValueError

            """
            self.ticket = ticket
            if self.ticket != 0:
                raise ValueError('ticket must be 0')
            self.destination = destination
            if len(self.destination) > 127:
                raise ValueError('Max length exceeded for destination')
            if not constants.DOMAIN_REGEX['exchange-name'].fullmatch(
                    self.destination):
                raise ValueError('Invalid value for destination')
            self.source = source
            if len(self.source) > 127:
                raise ValueError('Max length exceeded for source')
            if not constants.DOMAIN_REGEX['exchange-name'].fullmatch(
                    self.source):
                raise ValueError('Invalid value for source')
            self.routing_key = routing_key
            self.nowait = nowait
            self.arguments = arguments or {}

    class BindOk(base.Frame):
        """Confirm bind successful

        This method confirms that the bind was successful.

        """
        __annotations__: typing.Dict[str, object] = {}
        __slots__: typing.List[str] = []  # AMQ Method Attributes

        frame_id = 31  # AMQP Frame ID
        index = 0x0028001F  # pamqp Mapping Index
        name = 'Exchange.BindOk'
        synchronous = False  # Indicates if this is a synchronous AMQP method

    class Unbind(base.Frame):
        """Unbind an exchange from an exchange

        This method unbinds an exchange from an exchange.

        """
        __annotations__: typing.Dict[str, object] = {
            'ticket': int,
            'destination': str,
            'source': str,
            'routing_key': str,
            'nowait': bool,
            'arguments': typing.Optional[typing.Dict[str, common.FieldValue]]
        }
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'ticket', 'destination', 'source', 'routing_key', 'nowait',
            'arguments'
        ]

        frame_id = 40  # AMQP Frame ID
        index = 0x00280028  # pamqp Mapping Index
        name = 'Exchange.Unbind'
        synchronous = True  # Indicates if this is a synchronous AMQP method
        # Valid responses to this method
        valid_responses = ['Exchange.UnbindOk']

        # Class Attribute Types for unmarshaling
        _ticket = 'short'
        _destination = 'shortstr'
        _source = 'shortstr'
        _routing_key = 'shortstr'
        _nowait = 'bit'
        _arguments = 'table'

        def __init__(self,
                     ticket: int = 0,
                     destination: str = '',
                     source: str = '',
                     routing_key: str = '',
                     nowait: bool = False,
                     arguments: typing.Optional[
                         typing.Dict[str, common.FieldValue]] = None) -> None:
            """Initialize the :py:class:`Exchange.Unbind` class

            :param ticket: Deprecated, must be ``0``
            :param destination: exchange name
            :param source: exchange name
            :param routing_key: Routing key of binding
            :param nowait: Do not send a reply method
            :param arguments: Arguments of binding
            :raises: ValueError

            """
            self.ticket = ticket
            if self.ticket != 0:
                raise ValueError('ticket must be 0')
            self.destination = destination
            if len(self.destination) > 127:
                raise ValueError('Max length exceeded for destination')
            if not constants.DOMAIN_REGEX['exchange-name'].fullmatch(
                    self.destination):
                raise ValueError('Invalid value for destination')
            self.source = source
            if len(self.source) > 127:
                raise ValueError('Max length exceeded for source')
            if not constants.DOMAIN_REGEX['exchange-name'].fullmatch(
                    self.source):
                raise ValueError('Invalid value for source')
            self.routing_key = routing_key
            self.nowait = nowait
            self.arguments = arguments or {}

    class UnbindOk(base.Frame):
        """Confirm unbind successful

        This method confirms that the unbind was successful.

        """
        __annotations__: typing.Dict[str, object] = {}
        __slots__: typing.List[str] = []  # AMQ Method Attributes

        frame_id = 51  # AMQP Frame ID
        index = 0x00280033  # pamqp Mapping Index
        name = 'Exchange.UnbindOk'
        synchronous = False  # Indicates if this is a synchronous AMQP method


class Queue:
    """Work with queues

    Queues store and forward messages. Queues can be configured in the server
    or created at runtime. Queues must be attached to at least one exchange in
    order to receive messages from publishers.

    """
    __slots__: typing.List[str] = []

    frame_id = 50  # AMQP Frame ID
    index = 0x00320000  # pamqp Mapping Index

    class Declare(base.Frame):
        """Declare queue, create if needed

        This method creates or checks a queue. When creating a new queue the
        client can specify various properties that control the durability of
        the queue and its contents, and the level of sharing for the queue.

        """
        __annotations__: typing.Dict[str, object] = {
            'ticket': int,
            'queue': str,
            'passive': bool,
            'durable': bool,
            'exclusive': bool,
            'auto_delete': bool,
            'nowait': bool,
            'arguments': typing.Optional[typing.Dict[str, common.FieldValue]]
        }
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'ticket', 'queue', 'passive', 'durable', 'exclusive',
            'auto_delete', 'nowait', 'arguments'
        ]

        frame_id = 10  # AMQP Frame ID
        index = 0x0032000A  # pamqp Mapping Index
        name = 'Queue.Declare'
        synchronous = True  # Indicates if this is a synchronous AMQP method
        # Valid responses to this method
        valid_responses = ['Queue.DeclareOk']

        # Class Attribute Types for unmarshaling
        _ticket = 'short'
        _queue = 'shortstr'
        _passive = 'bit'
        _durable = 'bit'
        _exclusive = 'bit'
        _auto_delete = 'bit'
        _nowait = 'bit'
        _arguments = 'table'

        def __init__(self,
                     ticket: int = 0,
                     queue: str = '',
                     passive: bool = False,
                     durable: bool = False,
                     exclusive: bool = False,
                     auto_delete: bool = False,
                     nowait: bool = False,
                     arguments: typing.Optional[
                         typing.Dict[str, common.FieldValue]] = None) -> None:
            """Initialize the :py:class:`Queue.Declare` class

            :param ticket: Deprecated, must be ``0``
            :param queue: queue name
            :param passive: Do not create queue
            :param durable: Request a durable queue
            :param exclusive: Request an exclusive queue
            :param auto_delete: Auto-delete queue when unused
            :param nowait: Do not send a reply method
            :param arguments: Arguments for declaration
            :raises: ValueError

            """
            self.ticket = ticket
            if self.ticket != 0:
                raise ValueError('ticket must be 0')
            self.queue = queue
            if len(self.queue) > 127:
                raise ValueError('Max length exceeded for queue')
            if not constants.DOMAIN_REGEX['queue-name'].fullmatch(self.queue):
                raise ValueError('Invalid value for queue')
            self.passive = passive
            self.durable = durable
            self.exclusive = exclusive
            self.auto_delete = auto_delete
            self.nowait = nowait
            self.arguments = arguments or {}

    class DeclareOk(base.Frame):
        """Confirms a queue definition

        This method confirms a Declare method and confirms the name of the
        queue, essential for automatically-named queues.

        """
        __annotations__: typing.Dict[str, object] = {
            'queue': str,
            'message_count': int,
            'consumer_count': int
        }
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'queue', 'message_count', 'consumer_count'
        ]

        frame_id = 11  # AMQP Frame ID
        index = 0x0032000B  # pamqp Mapping Index
        name = 'Queue.DeclareOk'
        synchronous = False  # Indicates if this is a synchronous AMQP method

        # Class Attribute Types for unmarshaling
        _queue = 'shortstr'
        _message_count = 'long'
        _consumer_count = 'long'

        def __init__(self,
                     queue: str = '',
                     message_count: int = 0,
                     consumer_count: int = 0) -> None:
            """Initialize the :py:class:`Queue.DeclareOk` class

            :param queue: queue name
            :param message_count: number of messages in queue
            :param consumer_count: Number of consumers
            :raises: ValueError

            """
            self.queue = queue
            if len(self.queue) > 127:
                raise ValueError('Max length exceeded for queue')
            if not constants.DOMAIN_REGEX['queue-name'].fullmatch(self.queue):
                raise ValueError('Invalid value for queue')
            self.message_count = message_count
            self.consumer_count = consumer_count

    class Bind(base.Frame):
        """Bind queue to an exchange

        This method binds a queue to an exchange. Until a queue is bound it
        will not receive any messages. In a classic messaging model, store-and-
        forward queues are bound to a direct exchange and subscription queues
        are bound to a topic exchange.

        """
        __annotations__: typing.Dict[str, object] = {
            'ticket': int,
            'queue': str,
            'exchange': str,
            'routing_key': str,
            'nowait': bool,
            'arguments': typing.Optional[typing.Dict[str, common.FieldValue]]
        }
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'ticket', 'queue', 'exchange', 'routing_key', 'nowait', 'arguments'
        ]

        frame_id = 20  # AMQP Frame ID
        index = 0x00320014  # pamqp Mapping Index
        name = 'Queue.Bind'
        synchronous = True  # Indicates if this is a synchronous AMQP method
        valid_responses = ['Queue.BindOk']  # Valid responses to this method

        # Class Attribute Types for unmarshaling
        _ticket = 'short'
        _queue = 'shortstr'
        _exchange = 'shortstr'
        _routing_key = 'shortstr'
        _nowait = 'bit'
        _arguments = 'table'

        def __init__(self,
                     ticket: int = 0,
                     queue: str = '',
                     exchange: str = '',
                     routing_key: str = '',
                     nowait: bool = False,
                     arguments: typing.Optional[
                         typing.Dict[str, common.FieldValue]] = None) -> None:
            """Initialize the :py:class:`Queue.Bind` class

            :param ticket: Deprecated, must be ``0``
            :param queue: queue name
            :param exchange: exchange name
            :param routing_key: Message routing key
            :param nowait: Do not send a reply method
            :param arguments: Arguments for binding
            :raises: ValueError

            """
            self.ticket = ticket
            if self.ticket != 0:
                raise ValueError('ticket must be 0')
            self.queue = queue
            if len(self.queue) > 127:
                raise ValueError('Max length exceeded for queue')
            if not constants.DOMAIN_REGEX['queue-name'].fullmatch(self.queue):
                raise ValueError('Invalid value for queue')
            self.exchange = exchange
            if len(self.exchange) > 127:
                raise ValueError('Max length exceeded for exchange')
            if not constants.DOMAIN_REGEX['exchange-name'].fullmatch(
                    self.exchange):
                raise ValueError('Invalid value for exchange')
            self.routing_key = routing_key
            self.nowait = nowait
            self.arguments = arguments or {}

    class BindOk(base.Frame):
        """Confirm bind successful

        This method confirms that the bind was successful.

        """
        __annotations__: typing.Dict[str, object] = {}
        __slots__: typing.List[str] = []  # AMQ Method Attributes

        frame_id = 21  # AMQP Frame ID
        index = 0x00320015  # pamqp Mapping Index
        name = 'Queue.BindOk'
        synchronous = False  # Indicates if this is a synchronous AMQP method

    class Purge(base.Frame):
        """Purge a queue

        This method removes all messages from a queue which are not awaiting
        acknowledgment.

        """
        __annotations__: typing.Dict[str, object] = {
            'ticket': int,
            'queue': str,
            'nowait': bool
        }
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'ticket', 'queue', 'nowait'
        ]

        frame_id = 30  # AMQP Frame ID
        index = 0x0032001E  # pamqp Mapping Index
        name = 'Queue.Purge'
        synchronous = True  # Indicates if this is a synchronous AMQP method
        valid_responses = ['Queue.PurgeOk']  # Valid responses to this method

        # Class Attribute Types for unmarshaling
        _ticket = 'short'
        _queue = 'shortstr'
        _nowait = 'bit'

        def __init__(self,
                     ticket: int = 0,
                     queue: str = '',
                     nowait: bool = False) -> None:
            """Initialize the :py:class:`Queue.Purge` class

            :param ticket: Deprecated, must be ``0``
            :param queue: queue name
            :param nowait: Do not send a reply method
            :raises: ValueError

            """
            self.ticket = ticket
            if self.ticket != 0:
                raise ValueError('ticket must be 0')
            self.queue = queue
            if len(self.queue) > 127:
                raise ValueError('Max length exceeded for queue')
            if not constants.DOMAIN_REGEX['queue-name'].fullmatch(self.queue):
                raise ValueError('Invalid value for queue')
            self.nowait = nowait

    class PurgeOk(base.Frame):
        """Confirms a queue purge

        This method confirms the purge of a queue.

        """
        __annotations__: typing.Dict[str, object] = {'message_count': int}
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'message_count'
        ]

        frame_id = 31  # AMQP Frame ID
        index = 0x0032001F  # pamqp Mapping Index
        name = 'Queue.PurgeOk'
        synchronous = False  # Indicates if this is a synchronous AMQP method

        # Class Attribute Types for unmarshaling
        _message_count = 'long'

        def __init__(self, message_count: int = 0) -> None:
            """Initialize the :py:class:`Queue.PurgeOk` class

            :param message_count: number of messages in queue

            """
            self.message_count = message_count

    class Delete(base.Frame):
        """Delete a queue

        This method deletes a queue. When a queue is deleted any pending
        messages are sent to a dead-letter queue if this is defined in the
        server configuration, and all consumers on the queue are cancelled.

        """
        __annotations__: typing.Dict[str, object] = {
            'ticket': int,
            'queue': str,
            'if_unused': bool,
            'if_empty': bool,
            'nowait': bool
        }
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'ticket', 'queue', 'if_unused', 'if_empty', 'nowait'
        ]

        frame_id = 40  # AMQP Frame ID
        index = 0x00320028  # pamqp Mapping Index
        name = 'Queue.Delete'
        synchronous = True  # Indicates if this is a synchronous AMQP method
        valid_responses = ['Queue.DeleteOk']  # Valid responses to this method

        # Class Attribute Types for unmarshaling
        _ticket = 'short'
        _queue = 'shortstr'
        _if_unused = 'bit'
        _if_empty = 'bit'
        _nowait = 'bit'

        def __init__(self,
                     ticket: int = 0,
                     queue: str = '',
                     if_unused: bool = False,
                     if_empty: bool = False,
                     nowait: bool = False) -> None:
            """Initialize the :py:class:`Queue.Delete` class

            :param ticket: Deprecated, must be ``0``
            :param queue: queue name
            :param if_unused: Delete only if unused
            :param if_empty: Delete only if empty
            :param nowait: Do not send a reply method
            :raises: ValueError

            """
            self.ticket = ticket
            if self.ticket != 0:
                raise ValueError('ticket must be 0')
            self.queue = queue
            if len(self.queue) > 127:
                raise ValueError('Max length exceeded for queue')
            if not constants.DOMAIN_REGEX['queue-name'].fullmatch(self.queue):
                raise ValueError('Invalid value for queue')
            self.if_unused = if_unused
            self.if_empty = if_empty
            self.nowait = nowait

    class DeleteOk(base.Frame):
        """Confirm deletion of a queue

        This method confirms the deletion of a queue.

        """
        __annotations__: typing.Dict[str, object] = {'message_count': int}
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'message_count'
        ]

        frame_id = 41  # AMQP Frame ID
        index = 0x00320029  # pamqp Mapping Index
        name = 'Queue.DeleteOk'
        synchronous = False  # Indicates if this is a synchronous AMQP method

        # Class Attribute Types for unmarshaling
        _message_count = 'long'

        def __init__(self, message_count: int = 0) -> None:
            """Initialize the :py:class:`Queue.DeleteOk` class

            :param message_count: number of messages in queue

            """
            self.message_count = message_count

    class Unbind(base.Frame):
        """Unbind a queue from an exchange

        This method unbinds a queue from an exchange.

        """
        __annotations__: typing.Dict[str, object] = {
            'ticket': int,
            'queue': str,
            'exchange': str,
            'routing_key': str,
            'arguments': typing.Optional[typing.Dict[str, common.FieldValue]]
        }
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'ticket', 'queue', 'exchange', 'routing_key', 'arguments'
        ]

        frame_id = 50  # AMQP Frame ID
        index = 0x00320032  # pamqp Mapping Index
        name = 'Queue.Unbind'
        synchronous = True  # Indicates if this is a synchronous AMQP method
        valid_responses = ['Queue.UnbindOk']  # Valid responses to this method

        # Class Attribute Types for unmarshaling
        _ticket = 'short'
        _queue = 'shortstr'
        _exchange = 'shortstr'
        _routing_key = 'shortstr'
        _arguments = 'table'

        def __init__(self,
                     ticket: int = 0,
                     queue: str = '',
                     exchange: str = '',
                     routing_key: str = '',
                     arguments: typing.Optional[
                         typing.Dict[str, common.FieldValue]] = None) -> None:
            """Initialize the :py:class:`Queue.Unbind` class

            :param ticket: Deprecated, must be ``0``
            :param queue: queue name
            :param exchange: exchange name
            :param routing_key: Routing key of binding
            :param arguments: Arguments of binding
            :raises: ValueError

            """
            self.ticket = ticket
            if self.ticket != 0:
                raise ValueError('ticket must be 0')
            self.queue = queue
            if len(self.queue) > 127:
                raise ValueError('Max length exceeded for queue')
            if not constants.DOMAIN_REGEX['queue-name'].fullmatch(self.queue):
                raise ValueError('Invalid value for queue')
            self.exchange = exchange
            if len(self.exchange) > 127:
                raise ValueError('Max length exceeded for exchange')
            if not constants.DOMAIN_REGEX['exchange-name'].fullmatch(
                    self.exchange):
                raise ValueError('Invalid value for exchange')
            self.routing_key = routing_key
            self.arguments = arguments or {}

    class UnbindOk(base.Frame):
        """Confirm unbind successful

        This method confirms that the unbind was successful.

        """
        __annotations__: typing.Dict[str, object] = {}
        __slots__: typing.List[str] = []  # AMQ Method Attributes

        frame_id = 51  # AMQP Frame ID
        index = 0x00320033  # pamqp Mapping Index
        name = 'Queue.UnbindOk'
        synchronous = False  # Indicates if this is a synchronous AMQP method


class Basic:
    """Work with basic content

    The Basic class provides methods that support an industry-standard
    messaging model.

    """
    __slots__: typing.List[str] = []

    frame_id = 60  # AMQP Frame ID
    index = 0x003C0000  # pamqp Mapping Index

    class Qos(base.Frame):
        """Specify quality of service

        This method requests a specific quality of service. The QoS can be
        specified for the current channel or for all channels on the
        connection. The particular properties and semantics of a qos method
        always depend on the content class semantics. Though the qos method
        could in principle apply to both peers, it is currently meaningful only
        for the server.

        """
        __annotations__: typing.Dict[str, object] = {
            'prefetch_size': int,
            'prefetch_count': int,
            'global_': bool
        }
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'prefetch_size', 'prefetch_count', 'global_'
        ]

        frame_id = 10  # AMQP Frame ID
        index = 0x003C000A  # pamqp Mapping Index
        name = 'Basic.Qos'
        synchronous = True  # Indicates if this is a synchronous AMQP method
        valid_responses = ['Basic.QosOk']  # Valid responses to this method

        # Class Attribute Types for unmarshaling
        _prefetch_size = 'long'
        _prefetch_count = 'short'
        _global_ = 'bit'

        def __init__(self,
                     prefetch_size: int = 0,
                     prefetch_count: int = 0,
                     global_: bool = False) -> None:
            """Initialize the :py:class:`Basic.Qos` class

            :param prefetch_size: Prefetch window in octets
            :param prefetch_count: Prefetch window in messages
            :param global_: Apply to entire connection

            """
            self.prefetch_size = prefetch_size
            self.prefetch_count = prefetch_count
            self.global_ = global_

    class QosOk(base.Frame):
        """Confirm the requested qos

        This method tells the client that the requested QoS levels could be
        handled by the server. The requested QoS applies to all active
        consumers until a new QoS is defined.

        """
        __annotations__: typing.Dict[str, object] = {}
        __slots__: typing.List[str] = []  # AMQ Method Attributes

        frame_id = 11  # AMQP Frame ID
        index = 0x003C000B  # pamqp Mapping Index
        name = 'Basic.QosOk'
        synchronous = False  # Indicates if this is a synchronous AMQP method

    class Consume(base.Frame):
        """Start a queue consumer

        This method asks the server to start a "consumer", which is a transient
        request for messages from a specific queue. Consumers last as long as
        the channel they were declared on, or until the client cancels them.

        """
        __annotations__: typing.Dict[str, object] = {
            'ticket': int,
            'queue': str,
            'consumer_tag': str,
            'no_local': bool,
            'no_ack': bool,
            'exclusive': bool,
            'nowait': bool,
            'arguments': typing.Optional[typing.Dict[str, common.FieldValue]]
        }
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'ticket', 'queue', 'consumer_tag', 'no_local', 'no_ack',
            'exclusive', 'nowait', 'arguments'
        ]

        frame_id = 20  # AMQP Frame ID
        index = 0x003C0014  # pamqp Mapping Index
        name = 'Basic.Consume'
        synchronous = True  # Indicates if this is a synchronous AMQP method
        # Valid responses to this method
        valid_responses = ['Basic.ConsumeOk']

        # Class Attribute Types for unmarshaling
        _ticket = 'short'
        _queue = 'shortstr'
        _consumer_tag = 'shortstr'
        _no_local = 'bit'
        _no_ack = 'bit'
        _exclusive = 'bit'
        _nowait = 'bit'
        _arguments = 'table'

        def __init__(self,
                     ticket: int = 0,
                     queue: str = '',
                     consumer_tag: str = '',
                     no_local: bool = False,
                     no_ack: bool = False,
                     exclusive: bool = False,
                     nowait: bool = False,
                     arguments: typing.Optional[
                         typing.Dict[str, common.FieldValue]] = None) -> None:
            """Initialize the :py:class:`Basic.Consume` class

            :param ticket: Deprecated, must be ``0``
            :param queue: queue name
            :param consumer_tag: consumer tag
            :param no_local: do not deliver own messages
            :param no_ack: no acknowledgement needed
            :param exclusive: Request exclusive access
            :param nowait: Do not send a reply method
            :param arguments: Arguments for declaration
            :raises: ValueError

            """
            self.ticket = ticket
            if self.ticket != 0:
                raise ValueError('ticket must be 0')
            self.queue = queue
            if len(self.queue) > 127:
                raise ValueError('Max length exceeded for queue')
            if not constants.DOMAIN_REGEX['queue-name'].fullmatch(self.queue):
                raise ValueError('Invalid value for queue')
            self.consumer_tag = consumer_tag
            self.no_local = no_local
            self.no_ack = no_ack
            self.exclusive = exclusive
            self.nowait = nowait
            self.arguments = arguments or {}

    class ConsumeOk(base.Frame):
        """Confirm a new consumer

        The server provides the client with a consumer tag, which is used by
        the client for methods called on the consumer at a later stage.

        """
        __annotations__: typing.Dict[str, object] = {'consumer_tag': str}
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'consumer_tag'
        ]

        frame_id = 21  # AMQP Frame ID
        index = 0x003C0015  # pamqp Mapping Index
        name = 'Basic.ConsumeOk'
        synchronous = False  # Indicates if this is a synchronous AMQP method

        # Class Attribute Types for unmarshaling
        _consumer_tag = 'shortstr'

        def __init__(self, consumer_tag: str = '') -> None:
            """Initialize the :py:class:`Basic.ConsumeOk` class

            :param consumer_tag: consumer tag

            """
            self.consumer_tag = consumer_tag

    class Cancel(base.Frame):
        """End a queue consumer

        This method cancels a consumer. This does not affect already delivered
        messages, but it does mean the server will not send any more messages
        for that consumer. The client may receive an arbitrary number of
        messages in between sending the cancel method and receiving the cancel-
        ok reply.  It may also be sent from the server to the client in the
        event of the consumer being unexpectedly cancelled (i.e. cancelled for
        any reason other than the server receiving the corresponding
        basic.cancel from the client). This allows clients to be notified of
        the loss of consumers due to events such as queue deletion. Note that
        as it is not a MUST for clients to accept this method from the server,
        it is advisable for the broker to be able to identify those clients
        that are capable of accepting the method, through some means of
        capability negotiation.

        """
        __annotations__: typing.Dict[str, object] = {
            'consumer_tag': str,
            'nowait': bool
        }
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'consumer_tag', 'nowait'
        ]

        frame_id = 30  # AMQP Frame ID
        index = 0x003C001E  # pamqp Mapping Index
        name = 'Basic.Cancel'
        synchronous = True  # Indicates if this is a synchronous AMQP method
        valid_responses = ['Basic.CancelOk']  # Valid responses to this method

        # Class Attribute Types for unmarshaling
        _consumer_tag = 'shortstr'
        _nowait = 'bit'

        def __init__(self,
                     consumer_tag: str = '',
                     nowait: bool = False) -> None:
            """Initialize the :py:class:`Basic.Cancel` class

            :param consumer_tag: consumer tag
            :param nowait: Do not send a reply method

            """
            self.consumer_tag = consumer_tag
            self.nowait = nowait

    class CancelOk(base.Frame):
        """Confirm a cancelled consumer

        This method confirms that the cancellation was completed.

        """
        __annotations__: typing.Dict[str, object] = {'consumer_tag': str}
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'consumer_tag'
        ]

        frame_id = 31  # AMQP Frame ID
        index = 0x003C001F  # pamqp Mapping Index
        name = 'Basic.CancelOk'
        synchronous = False  # Indicates if this is a synchronous AMQP method

        # Class Attribute Types for unmarshaling
        _consumer_tag = 'shortstr'

        def __init__(self, consumer_tag: str = '') -> None:
            """Initialize the :py:class:`Basic.CancelOk` class

            :param consumer_tag: consumer tag

            """
            self.consumer_tag = consumer_tag

    class Publish(base.Frame):
        """Publish a message

        This method publishes a message to a specific exchange. The message
        will be routed to queues as defined by the exchange configuration and
        distributed to any active consumers when the transaction, if any, is
        committed.

        """
        __annotations__: typing.Dict[str, object] = {
            'ticket': int,
            'exchange': str,
            'routing_key': str,
            'mandatory': bool,
            'immediate': bool
        }
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'ticket', 'exchange', 'routing_key', 'mandatory', 'immediate'
        ]

        frame_id = 40  # AMQP Frame ID
        index = 0x003C0028  # pamqp Mapping Index
        name = 'Basic.Publish'
        synchronous = False  # Indicates if this is a synchronous AMQP method

        # Class Attribute Types for unmarshaling
        _ticket = 'short'
        _exchange = 'shortstr'
        _routing_key = 'shortstr'
        _mandatory = 'bit'
        _immediate = 'bit'

        def __init__(self,
                     ticket: int = 0,
                     exchange: str = '',
                     routing_key: str = '',
                     mandatory: bool = False,
                     immediate: bool = False) -> None:
            """Initialize the :py:class:`Basic.Publish` class

            :param ticket: Deprecated, must be ``0``
            :param exchange: exchange name
            :param routing_key: Message routing key
            :param mandatory: Indicate mandatory routing
            :param immediate: Request immediate delivery
            :raises: ValueError

            """
            self.ticket = ticket
            if self.ticket != 0:
                raise ValueError('ticket must be 0')
            self.exchange = exchange
            if len(self.exchange) > 127:
                raise ValueError('Max length exceeded for exchange')
            if not constants.DOMAIN_REGEX['exchange-name'].fullmatch(
                    self.exchange):
                raise ValueError('Invalid value for exchange')
            self.routing_key = routing_key
            self.mandatory = mandatory
            self.immediate = immediate

    class Return(base.Frame):
        """Return a failed message

        This method returns an undeliverable message that was published with
        the "immediate" flag set, or an unroutable message published with the
        "mandatory" flag set. The reply code and text provide information about
        the reason that the message was undeliverable.

        """
        __annotations__: typing.Dict[str, object] = {
            'reply_code': int,
            'reply_text': str,
            'exchange': str,
            'routing_key': str
        }
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'reply_code', 'reply_text', 'exchange', 'routing_key'
        ]

        frame_id = 50  # AMQP Frame ID
        index = 0x003C0032  # pamqp Mapping Index
        name = 'Basic.Return'
        synchronous = False  # Indicates if this is a synchronous AMQP method

        # Class Attribute Types for unmarshaling
        _reply_code = 'short'
        _reply_text = 'shortstr'
        _exchange = 'shortstr'
        _routing_key = 'shortstr'

        def __init__(self,
                     reply_code: int = 0,
                     reply_text: str = '',
                     exchange: str = '',
                     routing_key: str = '') -> None:
            """Initialize the :py:class:`Basic.Return` class

            :param reply_code: reply code from server
            :param reply_text: localised reply text
            :param exchange: exchange name
            :param routing_key: Message routing key
            :raises: ValueError

            """
            self.reply_code = reply_code
            self.reply_text = reply_text
            self.exchange = exchange
            if len(self.exchange) > 127:
                raise ValueError('Max length exceeded for exchange')
            if not constants.DOMAIN_REGEX['exchange-name'].fullmatch(
                    self.exchange):
                raise ValueError('Invalid value for exchange')
            self.routing_key = routing_key

    class Deliver(base.Frame):
        """Notify the client of a consumer message

        This method delivers a message to the client, via a consumer. In the
        asynchronous message delivery model, the client starts a consumer using
        the Consume method, then the server responds with Deliver methods as
        and when messages arrive for that consumer.

        """
        __annotations__: typing.Dict[str, object] = {
            'consumer_tag': str,
            'delivery_tag': int,
            'redelivered': bool,
            'exchange': str,
            'routing_key': str
        }
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'consumer_tag', 'delivery_tag', 'redelivered', 'exchange',
            'routing_key'
        ]

        frame_id = 60  # AMQP Frame ID
        index = 0x003C003C  # pamqp Mapping Index
        name = 'Basic.Deliver'
        synchronous = False  # Indicates if this is a synchronous AMQP method

        # Class Attribute Types for unmarshaling
        _consumer_tag = 'shortstr'
        _delivery_tag = 'longlong'
        _redelivered = 'bit'
        _exchange = 'shortstr'
        _routing_key = 'shortstr'

        def __init__(self,
                     consumer_tag: str = '',
                     delivery_tag: int = 0,
                     redelivered: bool = False,
                     exchange: str = '',
                     routing_key: str = '') -> None:
            """Initialize the :py:class:`Basic.Deliver` class

            :param consumer_tag: consumer tag
            :param delivery_tag: server-assigned delivery tag
            :param redelivered: message is being redelivered
            :param exchange: exchange name
            :param routing_key: Message routing key
            :raises: ValueError

            """
            self.consumer_tag = consumer_tag
            self.delivery_tag = delivery_tag
            self.redelivered = redelivered
            self.exchange = exchange
            if len(self.exchange) > 127:
                raise ValueError('Max length exceeded for exchange')
            if not constants.DOMAIN_REGEX['exchange-name'].fullmatch(
                    self.exchange):
                raise ValueError('Invalid value for exchange')
            self.routing_key = routing_key

    class Get(base.Frame):
        """Direct access to a queue

        This method provides a direct access to the messages in a queue using a
        synchronous dialogue that is designed for specific types of application
        where synchronous functionality is more important than performance.

        """
        __annotations__: typing.Dict[str, object] = {
            'ticket': int,
            'queue': str,
            'no_ack': bool
        }
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'ticket', 'queue', 'no_ack'
        ]

        frame_id = 70  # AMQP Frame ID
        index = 0x003C0046  # pamqp Mapping Index
        name = 'Basic.Get'
        synchronous = True  # Indicates if this is a synchronous AMQP method
        # Valid responses to this method
        valid_responses = ['Basic.GetOk', 'Basic.GetEmpty']

        # Class Attribute Types for unmarshaling
        _ticket = 'short'
        _queue = 'shortstr'
        _no_ack = 'bit'

        def __init__(self,
                     ticket: int = 0,
                     queue: str = '',
                     no_ack: bool = False) -> None:
            """Initialize the :py:class:`Basic.Get` class

            :param ticket: Deprecated, must be ``0``
            :param queue: queue name
            :param no_ack: no acknowledgement needed
            :raises: ValueError

            """
            self.ticket = ticket
            if self.ticket != 0:
                raise ValueError('ticket must be 0')
            self.queue = queue
            if len(self.queue) > 127:
                raise ValueError('Max length exceeded for queue')
            if not constants.DOMAIN_REGEX['queue-name'].fullmatch(self.queue):
                raise ValueError('Invalid value for queue')
            self.no_ack = no_ack

    class GetOk(base.Frame):
        """Provide client with a message

        This method delivers a message to the client following a get method. A
        message delivered by 'get-ok' must be acknowledged unless the no-ack
        option was set in the get method.

        """
        __annotations__: typing.Dict[str, object] = {
            'delivery_tag': int,
            'redelivered': bool,
            'exchange': str,
            'routing_key': str,
            'message_count': int
        }
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'delivery_tag', 'redelivered', 'exchange', 'routing_key',
            'message_count'
        ]

        frame_id = 71  # AMQP Frame ID
        index = 0x003C0047  # pamqp Mapping Index
        name = 'Basic.GetOk'
        synchronous = False  # Indicates if this is a synchronous AMQP method

        # Class Attribute Types for unmarshaling
        _delivery_tag = 'longlong'
        _redelivered = 'bit'
        _exchange = 'shortstr'
        _routing_key = 'shortstr'
        _message_count = 'long'

        def __init__(self,
                     delivery_tag: int = 0,
                     redelivered: bool = False,
                     exchange: str = '',
                     routing_key: str = '',
                     message_count: int = 0) -> None:
            """Initialize the :py:class:`Basic.GetOk` class

            :param delivery_tag: server-assigned delivery tag
            :param redelivered: message is being redelivered
            :param exchange: exchange name
            :param routing_key: Message routing key
            :param message_count: number of messages in queue
            :raises: ValueError

            """
            self.delivery_tag = delivery_tag
            self.redelivered = redelivered
            self.exchange = exchange
            if len(self.exchange) > 127:
                raise ValueError('Max length exceeded for exchange')
            if not constants.DOMAIN_REGEX['exchange-name'].fullmatch(
                    self.exchange):
                raise ValueError('Invalid value for exchange')
            self.routing_key = routing_key
            self.message_count = message_count

    class GetEmpty(base.Frame):
        """Indicate no messages available

        This method tells the client that the queue has no messages available
        for the client.

        """
        __annotations__: typing.Dict[str, object] = {'cluster_id': str}
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'cluster_id'
        ]

        frame_id = 72  # AMQP Frame ID
        index = 0x003C0048  # pamqp Mapping Index
        name = 'Basic.GetEmpty'
        synchronous = False  # Indicates if this is a synchronous AMQP method

        # Class Attribute Types for unmarshaling
        _cluster_id = 'shortstr'

        def __init__(self, cluster_id: str = '') -> None:
            """Initialize the :py:class:`Basic.GetEmpty` class

            :param cluster_id: Deprecated, must be empty

            """
            self.cluster_id = cluster_id
            if self.cluster_id != '':
                raise ValueError('cluster_id must be empty')

    class Ack(base.Frame):
        """Acknowledge one or more messages

        When sent by the client, this method acknowledges one or more messages
        delivered via the Deliver or Get-Ok methods.  When sent by server, this
        method acknowledges one or more messages published with the Publish
        method on a channel in confirm mode.  The acknowledgement can be for a
        single message or a set of messages up to and including a specific
        message.

        """
        __annotations__: typing.Dict[str, object] = {
            'delivery_tag': int,
            'multiple': bool
        }
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'delivery_tag', 'multiple'
        ]

        frame_id = 80  # AMQP Frame ID
        index = 0x003C0050  # pamqp Mapping Index
        name = 'Basic.Ack'
        synchronous = False  # Indicates if this is a synchronous AMQP method

        # Class Attribute Types for unmarshaling
        _delivery_tag = 'longlong'
        _multiple = 'bit'

        def __init__(self,
                     delivery_tag: int = 0,
                     multiple: bool = False) -> None:
            """Initialize the :py:class:`Basic.Ack` class

            :param delivery_tag: server-assigned delivery tag
            :param multiple: Acknowledge multiple messages

            """
            self.delivery_tag = delivery_tag
            self.multiple = multiple

    class Reject(base.Frame):
        """Reject an incoming message

        This method allows a client to reject a message. It can be used to
        interrupt and cancel large incoming messages, or return untreatable
        messages to their original queue.

        """
        __annotations__: typing.Dict[str, object] = {
            'delivery_tag': int,
            'requeue': bool
        }
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'delivery_tag', 'requeue'
        ]

        frame_id = 90  # AMQP Frame ID
        index = 0x003C005A  # pamqp Mapping Index
        name = 'Basic.Reject'
        synchronous = False  # Indicates if this is a synchronous AMQP method

        # Class Attribute Types for unmarshaling
        _delivery_tag = 'longlong'
        _requeue = 'bit'

        def __init__(self,
                     delivery_tag: int = 0,
                     requeue: bool = True) -> None:
            """Initialize the :py:class:`Basic.Reject` class

            :param delivery_tag: server-assigned delivery tag
            :param requeue: Requeue the message

            """
            self.delivery_tag = delivery_tag
            self.requeue = requeue

    class RecoverAsync(base.Frame):
        """Redeliver unacknowledged messages

        This method asks the server to redeliver all unacknowledged messages on
        a specified channel. Zero or more messages may be redelivered.  This
        method is deprecated in favour of the synchronous Recover/Recover-Ok.

        """
        __annotations__: typing.Dict[str, object] = {'requeue': bool}
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'requeue'
        ]

        frame_id = 100  # AMQP Frame ID
        index = 0x003C0064  # pamqp Mapping Index
        name = 'Basic.RecoverAsync'
        synchronous = False  # Indicates if this is a synchronous AMQP method

        # Class Attribute Types for unmarshaling
        _requeue = 'bit'

        def __init__(self, requeue: bool = False) -> None:
            """Initialize the :py:class:`Basic.RecoverAsync` class

            .. deprecated:: This command is deprecated in AMQP 0-9-1

            :param requeue: Requeue the message

            """
            self.requeue = requeue
            warnings.warn(constants.DEPRECATION_WARNING,
                          category=DeprecationWarning)

    class Recover(base.Frame):
        """Redeliver unacknowledged messages

        This method asks the server to redeliver all unacknowledged messages on
        a specified channel. Zero or more messages may be redelivered.  This
        method replaces the asynchronous Recover.

        """
        __annotations__: typing.Dict[str, object] = {'requeue': bool}
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'requeue'
        ]

        frame_id = 110  # AMQP Frame ID
        index = 0x003C006E  # pamqp Mapping Index
        name = 'Basic.Recover'
        synchronous = True  # Indicates if this is a synchronous AMQP method
        # Valid responses to this method
        valid_responses = ['Basic.RecoverOk']

        # Class Attribute Types for unmarshaling
        _requeue = 'bit'

        def __init__(self, requeue: bool = False) -> None:
            """Initialize the :py:class:`Basic.Recover` class

            :param requeue: Requeue the message

            """
            self.requeue = requeue

    class RecoverOk(base.Frame):
        """Confirm recovery

        This method acknowledges a Basic.Recover method.

        """
        __annotations__: typing.Dict[str, object] = {}
        __slots__: typing.List[str] = []  # AMQ Method Attributes

        frame_id = 111  # AMQP Frame ID
        index = 0x003C006F  # pamqp Mapping Index
        name = 'Basic.RecoverOk'
        synchronous = False  # Indicates if this is a synchronous AMQP method

    class Nack(base.Frame):
        """Reject one or more incoming messages

        This method allows a client to reject one or more incoming messages. It
        can be used to interrupt and cancel large incoming messages, or return
        untreatable messages to their original queue.  This method is also used
        by the server to inform publishers on channels in confirm mode of
        unhandled messages.  If a publisher receives this method, it probably
        needs to republish the offending messages.

        """
        __annotations__: typing.Dict[str, object] = {
            'delivery_tag': int,
            'multiple': bool,
            'requeue': bool
        }
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'delivery_tag', 'multiple', 'requeue'
        ]

        frame_id = 120  # AMQP Frame ID
        index = 0x003C0078  # pamqp Mapping Index
        name = 'Basic.Nack'
        synchronous = False  # Indicates if this is a synchronous AMQP method

        # Class Attribute Types for unmarshaling
        _delivery_tag = 'longlong'
        _multiple = 'bit'
        _requeue = 'bit'

        def __init__(self,
                     delivery_tag: int = 0,
                     multiple: bool = False,
                     requeue: bool = True) -> None:
            """Initialize the :py:class:`Basic.Nack` class

            :param delivery_tag: server-assigned delivery tag
            :param multiple: Reject multiple messages
            :param requeue: Requeue the message

            """
            self.delivery_tag = delivery_tag
            self.multiple = multiple
            self.requeue = requeue

    class Properties(base.BasicProperties):
        """Content Properties"""
        __annotations__: typing.Dict[str, object] = {
            'content_type': str,
            'content_encoding': str,
            'headers': typing.Optional[typing.Dict[str, common.FieldValue]],
            'delivery_mode': int,
            'priority': int,
            'correlation_id': str,
            'reply_to': str,
            'expiration': str,
            'message_id': str,
            'timestamp': typing.Optional[datetime.datetime],
            'message_type': str,
            'user_id': str,
            'app_id': str,
            'cluster_id': str
        }
        __slots__: typing.List[str] = [  # AMQ Properties Attributes
            'content_type', 'content_encoding', 'headers', 'delivery_mode',
            'priority', 'correlation_id', 'reply_to', 'expiration',
            'message_id', 'timestamp', 'message_type', 'user_id', 'app_id',
            'cluster_id'
        ]

        # Flag values for marshaling / unmarshaling
        flags = {
            'content_type': 32768,
            'content_encoding': 16384,
            'headers': 8192,
            'delivery_mode': 4096,
            'priority': 2048,
            'correlation_id': 1024,
            'reply_to': 512,
            'expiration': 256,
            'message_id': 128,
            'timestamp': 64,
            'message_type': 32,
            'user_id': 16,
            'app_id': 8,
            'cluster_id': 4
        }

        frame_id = 60  # AMQP Frame ID
        index = 0x003C  # pamqp Mapping Index
        name = 'Basic.Properties'

        # Class Attribute Types for unmarshaling
        _content_type = 'shortstr'
        _content_encoding = 'shortstr'
        _headers = 'table'
        _delivery_mode = 'octet'
        _priority = 'octet'
        _correlation_id = 'shortstr'
        _reply_to = 'shortstr'
        _expiration = 'shortstr'
        _message_id = 'shortstr'
        _timestamp = 'timestamp'
        _message_type = 'shortstr'
        _user_id = 'shortstr'
        _app_id = 'shortstr'
        _cluster_id = 'shortstr'

        def __init__(self,
                     content_type: str = '',
                     content_encoding: str = '',
                     headers: typing.Optional[
                         typing.Dict[str, common.FieldValue]] = None,
                     delivery_mode: int = 0,
                     priority: int = 0,
                     correlation_id: str = '',
                     reply_to: str = '',
                     expiration: str = '',
                     message_id: str = '',
                     timestamp: typing.Optional[datetime.datetime] = None,
                     message_type: str = '',
                     user_id: str = '',
                     app_id: str = '',
                     cluster_id: str = '') -> None:
            """Initialize the Basic.Properties class

            .. Note:: The AMQP property type is named ``message_type`` as to
                      not conflict with the Python ``type`` keyword

            :param content_type: MIME content type
            :param content_encoding: MIME content encoding
            :param headers: Message header field table
            :param delivery_mode: Non-persistent (1) or persistent (2)
            :param priority: Message priority, 0 to 9
            :param correlation_id: Application correlation identifier
            :param reply_to: Address to reply to
            :param expiration: Message expiration specification
            :param message_id: Application message identifier
            :param timestamp: Message timestamp
            :param message_type: Message type name
            :param user_id: Creating user id
            :param app_id: Creating application id
            :param cluster_id: Deprecated, must be empty
            :raises: ValueError

            """
            self.content_type = content_type
            self.content_encoding = content_encoding
            self.headers = headers
            self.delivery_mode = delivery_mode
            self.priority = priority
            self.correlation_id = correlation_id
            self.reply_to = reply_to
            self.expiration = expiration
            self.message_id = message_id
            self.timestamp = timestamp
            self.message_type = message_type
            self.user_id = user_id
            self.app_id = app_id
            self.cluster_id = cluster_id
            if self.cluster_id != '':
                raise ValueError('cluster_id must be empty')


class Tx:
    """Work with transactions

    The Tx class allows publish and ack operations to be batched into atomic
    units of work.  The intention is that all publish and ack requests issued
    within a transaction will complete successfully or none of them will.
    Servers SHOULD implement atomic transactions at least where all publish or
    ack requests affect a single queue.  Transactions that cover multiple
    queues may be non-atomic, given that queues can be created and destroyed
    asynchronously, and such events do not form part of any transaction.
    Further, the behaviour of transactions with respect to the immediate and
    mandatory flags on Basic.Publish methods is not defined.

    """
    __slots__: typing.List[str] = []

    frame_id = 90  # AMQP Frame ID
    index = 0x005A0000  # pamqp Mapping Index

    class Select(base.Frame):
        """Select standard transaction mode

        This method sets the channel to use standard transactions. The client
        must use this method at least once on a channel before using the Commit
        or Rollback methods.

        """
        __annotations__: typing.Dict[str, object] = {}
        __slots__: typing.List[str] = []  # AMQ Method Attributes

        frame_id = 10  # AMQP Frame ID
        index = 0x005A000A  # pamqp Mapping Index
        name = 'Tx.Select'
        synchronous = True  # Indicates if this is a synchronous AMQP method
        valid_responses = ['Tx.SelectOk']  # Valid responses to this method

    class SelectOk(base.Frame):
        """Confirm transaction mode

        This method confirms to the client that the channel was successfully
        set to use standard transactions.

        """
        __annotations__: typing.Dict[str, object] = {}
        __slots__: typing.List[str] = []  # AMQ Method Attributes

        frame_id = 11  # AMQP Frame ID
        index = 0x005A000B  # pamqp Mapping Index
        name = 'Tx.SelectOk'
        synchronous = False  # Indicates if this is a synchronous AMQP method

    class Commit(base.Frame):
        """Commit the current transaction

        This method commits all message publications and acknowledgments
        performed in the current transaction.  A new transaction starts
        immediately after a commit.

        """
        __annotations__: typing.Dict[str, object] = {}
        __slots__: typing.List[str] = []  # AMQ Method Attributes

        frame_id = 20  # AMQP Frame ID
        index = 0x005A0014  # pamqp Mapping Index
        name = 'Tx.Commit'
        synchronous = True  # Indicates if this is a synchronous AMQP method
        valid_responses = ['Tx.CommitOk']  # Valid responses to this method

    class CommitOk(base.Frame):
        """Confirm a successful commit

        This method confirms to the client that the commit succeeded. Note that
        if a commit fails, the server raises a channel exception.

        """
        __annotations__: typing.Dict[str, object] = {}
        __slots__: typing.List[str] = []  # AMQ Method Attributes

        frame_id = 21  # AMQP Frame ID
        index = 0x005A0015  # pamqp Mapping Index
        name = 'Tx.CommitOk'
        synchronous = False  # Indicates if this is a synchronous AMQP method

    class Rollback(base.Frame):
        """Abandon the current transaction

        This method abandons all message publications and acknowledgments
        performed in the current transaction. A new transaction starts
        immediately after a rollback. Note that unacked messages will not be
        automatically redelivered by rollback; if that is required an explicit
        recover call should be issued.

        """
        __annotations__: typing.Dict[str, object] = {}
        __slots__: typing.List[str] = []  # AMQ Method Attributes

        frame_id = 30  # AMQP Frame ID
        index = 0x005A001E  # pamqp Mapping Index
        name = 'Tx.Rollback'
        synchronous = True  # Indicates if this is a synchronous AMQP method
        valid_responses = ['Tx.RollbackOk']  # Valid responses to this method

    class RollbackOk(base.Frame):
        """Confirm successful rollback

        This method confirms to the client that the rollback succeeded. Note
        that if an rollback fails, the server raises a channel exception.

        """
        __annotations__: typing.Dict[str, object] = {}
        __slots__: typing.List[str] = []  # AMQ Method Attributes

        frame_id = 31  # AMQP Frame ID
        index = 0x005A001F  # pamqp Mapping Index
        name = 'Tx.RollbackOk'
        synchronous = False  # Indicates if this is a synchronous AMQP method


class Confirm:
    """Work with confirms

    The Confirm class allows publishers to put the channel in confirm mode and
    subsequently be notified when messages have been handled by the broker.
    The intention is that all messages published on a channel in confirm mode
    will be acknowledged at some point.  By acknowledging a message the broker
    assumes responsibility for it and indicates that it has done something it
    deems reasonable with it.  Unroutable mandatory or immediate messages are
    acknowledged right after the Basic.Return method. Messages are acknowledged
    when all queues to which the message has been routed have either delivered
    the message and received an acknowledgement (if required), or enqueued the
    message (and persisted it if required).  Published messages are assigned
    ascending sequence numbers, starting at 1 with the first Confirm.Select
    method. The server confirms messages by sending Basic.Ack methods referring
    to these sequence numbers.

    """
    __slots__: typing.List[str] = []

    frame_id = 85  # AMQP Frame ID
    index = 0x00550000  # pamqp Mapping Index

    class Select(base.Frame):
        """Select confirm mode (i.e. enable publisher acknowledgements)

        This method sets the channel to use publisher acknowledgements. The
        client can only use this method on a non-transactional channel.

        """
        __annotations__: typing.Dict[str, object] = {'nowait': bool}
        __slots__: typing.List[str] = [  # AMQ Method Attributes
            'nowait'
        ]

        frame_id = 10  # AMQP Frame ID
        index = 0x0055000A  # pamqp Mapping Index
        name = 'Confirm.Select'
        synchronous = True  # Indicates if this is a synchronous AMQP method
        # Valid responses to this method
        valid_responses = ['Confirm.SelectOk']

        # Class Attribute Types for unmarshaling
        _nowait = 'bit'

        def __init__(self, nowait: bool = False) -> None:
            """Initialize the :py:class:`Confirm.Select` class

            :param nowait: Do not send a reply method

            """
            self.nowait = nowait

    class SelectOk(base.Frame):
        """Acknowledge confirm mode

        This method confirms to the client that the channel was successfully
        set to use publisher acknowledgements.

        """
        __annotations__: typing.Dict[str, object] = {}
        __slots__: typing.List[str] = []  # AMQ Method Attributes

        frame_id = 11  # AMQP Frame ID
        index = 0x0055000B  # pamqp Mapping Index
        name = 'Confirm.SelectOk'
        synchronous = False  # Indicates if this is a synchronous AMQP method


# AMQP Class.Method Index Mapping
INDEX_MAPPING = {
    0x000A000A: Connection.Start,
    0x000A000B: Connection.StartOk,
    0x000A0014: Connection.Secure,
    0x000A0015: Connection.SecureOk,
    0x000A001E: Connection.Tune,
    0x000A001F: Connection.TuneOk,
    0x000A0028: Connection.Open,
    0x000A0029: Connection.OpenOk,
    0x000A0032: Connection.Close,
    0x000A0033: Connection.CloseOk,
    0x000A003C: Connection.Blocked,
    0x000A003D: Connection.Unblocked,
    0x000A0046: Connection.UpdateSecret,
    0x000A0047: Connection.UpdateSecretOk,
    0x0014000A: Channel.Open,
    0x0014000B: Channel.OpenOk,
    0x00140014: Channel.Flow,
    0x00140015: Channel.FlowOk,
    0x00140028: Channel.Close,
    0x00140029: Channel.CloseOk,
    0x0028000A: Exchange.Declare,
    0x0028000B: Exchange.DeclareOk,
    0x00280014: Exchange.Delete,
    0x00280015: Exchange.DeleteOk,
    0x0028001E: Exchange.Bind,
    0x0028001F: Exchange.BindOk,
    0x00280028: Exchange.Unbind,
    0x00280033: Exchange.UnbindOk,
    0x0032000A: Queue.Declare,
    0x0032000B: Queue.DeclareOk,
    0x00320014: Queue.Bind,
    0x00320015: Queue.BindOk,
    0x0032001E: Queue.Purge,
    0x0032001F: Queue.PurgeOk,
    0x00320028: Queue.Delete,
    0x00320029: Queue.DeleteOk,
    0x00320032: Queue.Unbind,
    0x00320033: Queue.UnbindOk,
    0x003C000A: Basic.Qos,
    0x003C000B: Basic.QosOk,
    0x003C0014: Basic.Consume,
    0x003C0015: Basic.ConsumeOk,
    0x003C001E: Basic.Cancel,
    0x003C001F: Basic.CancelOk,
    0x003C0028: Basic.Publish,
    0x003C0032: Basic.Return,
    0x003C003C: Basic.Deliver,
    0x003C0046: Basic.Get,
    0x003C0047: Basic.GetOk,
    0x003C0048: Basic.GetEmpty,
    0x003C0050: Basic.Ack,
    0x003C005A: Basic.Reject,
    0x003C0064: Basic.RecoverAsync,
    0x003C006E: Basic.Recover,
    0x003C006F: Basic.RecoverOk,
    0x003C0078: Basic.Nack,
    0x005A000A: Tx.Select,
    0x005A000B: Tx.SelectOk,
    0x005A0014: Tx.Commit,
    0x005A0015: Tx.CommitOk,
    0x005A001E: Tx.Rollback,
    0x005A001F: Tx.RollbackOk,
    0x0055000A: Confirm.Select,
    0x0055000B: Confirm.SelectOk
}
